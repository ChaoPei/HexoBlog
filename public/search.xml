<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac+Hexo+GitHub博客搭建教程]]></title>
    <url>%2F2018%2F03%2F16%2FMac%2BHexo%2BGitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.为什么写博客以前利用Jekyll+Github搭建博客，但每次博客搭建完成后都没有继续坚持写博文，直到最近找实习才认识到技术博客的重要性。以前学习的很多知识点都已经忘记啦，所以下定决心这次认真总结以前学习的知识点，认真写点技术文章。 2.Mac+Hexo+GitHub博客现在博客主流的就是Jekyll和Hexo两种格式，选择Jekyll还是Hexo就根据个人喜好啦，但个人更推荐使用Hexo，选择Hexo的主要原因。 Jekyll没有本地服务器，无法实现本地文章预览，需要上传到WEB容器中才能预览功能，而Hexo可以通过简单的命令实现本地预览功能，并直接发布到WEB容器中实现同步。 Jekyll主题和Hexo主题对比而言，Hexo主题更加简洁美观(个人审美原因)。 选择GitHub的原因不用多说，程序员的乐园，更是支持pages功能，虽然很多其他社区也支持，比如GitLab、coding、码云等，但GitHub更加活跃，自己的项目就是放在上面，所以更加方便。但GitHub有最大一点不好之处便是百度爬虫无法爬去博客内容，自己也找了好久解决方法，比如利用coding托管(免费版绑定域名有广告)、CDN加速(对于流量太小的网站没什么用)，所以暂时没什么太好的解决方法。 3.博客本地环境搭建3.1安装Node.js和GitMac上安装可以选择图形化方式和终端安装，此处直接使用客户端方式安装。Node.js官网下载文件，根据提示安装即可，安装成功后在目录/usr/local/bin目录下。测试Node.js和npm，出现下述信息则安装成功。 12node -vv8.10.0 12npm -v5.6.0 Git官网下载相应文件根据提示直接进行安装，检查git是否安装成功，直接查看git版本即可。 Git –version git version 2.15.0 3.2安装HexoNode.js和Git都安装成功后开始安装Hexo。安装时注意权限问题，加上sudo，其中-g表示全局安装。 1sudo npm install -g hexo 3.3博客初始化创建存储博客的文件，比如命名为myblog，然后进入到myblog之中。 1cd myblog 执行下述命令初始化本地博客，下载一些列文件。 1hexo init 执行下述命令安装npm。 1sudo npm install 执行下述命令生成本地html文件并开启服务器，然后通过http://localhost:4000查看本地博客。 12hexo ghexo s 4.本地博客关联GitHub4.1本地博客代码上传GitHub注册并登陆GitHub账号后，新建仓库，名称必须为user.github.io，如weizhixiaoyi.github.io。 终端cd到myblog文件夹下，打开_config.yml文件。或者用其他文本编辑器打开可以，推荐sublime。 1vim _config.yml 打开后至文档最后部分，将deploy配置如下。 1234deploy: type: git repository: https://github.com/weizhixiaoyi/weizhixiaoyi.github.io.git branch: master 其中将repository中weizhixiaoyi改为自己的用户名，注意type、repository、branch后均有空格。通过如下命令在myblog下生成静态文件并上传到服务器。 12hexo ghexo d 若执行hexo g出错则执行npm install hexo --save，若执行hexo d出错则执行npm install hexo-deployer-git --save。错误修正后再次执行hexo g和hexo d。 若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即: 12username for 'https://github.com':password for 'https://github.com': hexo d执行成功后便可通过https://weizhixiaoyi.github.io访问博客，看到的内容和http://localhost:4000相同。 4.2添加ssh keys到GitHub添加ssh key后不需要每次更新博客再输入用户名和密码。首先检查本地是否包含ssh keys。如果存在则直接将ssh key添加到GitHub之中，否则进入新生成ssh key。 执行下述命令生成新的ssh key，将`your_email@example.com改成自己以注册的GitHub邮箱地址。默认会在~/.ssh/id_rsa.pub中生成id_rsa和id_rsa.pub`文件。 1ssh-keygen -t rsa -C "your_email@exampl" Mac下利用open ~/.ssh打开文件夹，打开id_rsa.pub文件，里面的信息即为ssh key，将此信息复制到GitHub的Add ssh key路径GitHub-&gt;Setting-&gt;SSH keys-&gt;add SSH key界面即可。Title里填写任意标题，将复制的内容粘贴到key中，点击Add key完成添加。 此时本地博客内容便已关联到GitHub之中，本地博客改变之后，通过hexo g和hexo d便可更新到GitHub之中，通过https://weizhixiaoyi.github.io访问便可看到更新内容。 5.更换Hexo主题可以选择Hexo主题官网页面搜索喜欢的theme，这里我选择hexo-theme-next当作自己主题，hex-theme-next主题是GitHub中hexo主题star最高的项目，非常推荐使用。 终端cd到myblog目录下执行如下所示命令。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 将blog目录下_config.yml里的theme的名称landscape更改为next。 执行如下命令（每次部署文章的步骤） 12hexo g //生成缓存和静态文件hexo d //重新部署到服务器 当本地博客部署到服务器后，网页端无变化时可以采用下述命令。 1hexo clean //清楚缓存文件(db.json)和已生成的静态文件(public) 6.配置Hexo-theme-next主题Hexo-theme-next主题便为精于心、简于形，简介的界面下能够呈现丰富的内容，访问next官网查看配置内容。配置文件主要修改next中_config.yml文件，next有三种主题选择，分别为Muse、Mist、Pisces三种，个人选择的是Pisces主题。主题增加标签、分类、归档、喜欢（书籍和电影信息流）、文章阅读统计、访问人数统计、评论等功能，博客界面如下所示。 6.1增加标签、分类、归档页首先将next/config.yml文件中将menu中tags catagories archive前面的#。例如增加标签页，通过hexo new page &#39;tags&#39;增加新界面，在myblog/sources中发现多了tags文件夹，修改index.md中内容，将type更改为tags。利用hexo g和hexo d将界面重新上传到服务器便可看到新增加的标签页，分类和归档页同理。 6.2增加‘喜欢’界面‘喜欢’界面用于展现自己看过的书籍和电影。 安装]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之MatPlotLib使用教程]]></title>
    <url>%2F2018%2F03%2F14%2FPython%E4%B9%8BMatPlotLib%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.Matplotlib简介 Matplotlib是非常强大的python画图工具 Matplotlib可以画图线图、散点图、等高线图、条形图、柱形图、3D图形、图形动画等。 2.Matplotlib安装1pip3 install matplotlib#python3 3.Matplotlib引入123import matplotlib.pyplot as plt#为方便简介为pltimport numpy as np#画图过程中会使用numpyimport pandas as pd#画图过程中会使用pandas 4.Matplotlib基本应用123456x=np.linspace(-1,1,50)#定义x数据范围y1=2*x+1#定义y数据范围y2=x**2plt.figure()#定义一个图像窗口plt.plot(x,y)#plot()画出曲线plt.show()#显示图像 4.1figure图像matplotlib的figure为单独图像窗口，小窗口内还可以有更多的小图片。1234567x=np.linspace(-3,3,50)#50为生成的样本数y1=2*x+1y2=x**2plt.figure(num=1,figsize=(8,5))#定义编号为1 大小为(8,5)plt.plot(x,y1,color='red',linewidth=2,linestyle='--')#颜色为红色，线宽度为2，线风格为--plt.plot(x,y2)#进行画图plt.show()#显示图 4.2设置坐标轴1234567891011x=np.linspace(-3,3,50)y1=2*x+1y2=x**2plt.figure(num=2,figsize=(8,5))plt.plot(x,y1,color='red',linewidth=2,linestyle='-')plt.plot(x,y2)#进行画图plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel("I'm x")plt.ylabel("I'm y")plt.show() 自定义坐标轴1234567891011121314151617x=np.linspace(-3,3,50)y1=2*x+1y2=x**2plt.figure(num=2,figsize=(8,5))plt.plot(x,y1,color='red',linewidth=2,linestyle='-')plt.plot(x,y2)#进行画图plt.xlim(-1,2)plt.ylim(-2,3)plt.xlabel("I'm x")plt.ylabel("I'm y")new_ticks=np.linspace(-1,2,5)#小标从-1到2分为5个单位print(new_ticks)#[-1. -0.25 0.5 1.25 2. ]plt.xticks(new_ticks)#进行替换新下标plt.yticks([-2,-1,1,2,], [r'$really\ bad$','$bad$','$well$','$really\ well$'])plt.show() 设置边框属性12345678910111213141516x=np.linspace(-3,3,50)y1=2*x+1y2=x**2plt.figure(num=2,figsize=(8,5))plt.plot(x,y1,color='red',linewidth=2,linestyle='--')plt.plot(x,y2)#进行画图plt.xlim(-1,2)plt.ylim(-2,3)new_ticks=np.linspace(-1,2,5)#小标从-1到2分为5个单位plt.xticks(new_ticks)#进行替换新下标plt.yticks([-2,-1,1,2,], [r'$really\ bad$','$bad$','$well$','$really\ well$'])ax=plt.gca()#gca=get current axisax.spines['right'].set_color('none')#边框属性设置为none 不显示ax.spines['top'].set_color('none')plt.show() 调整移动坐标轴1234567891011121314151617181920x=np.linspace(-3,3,50)y1=2*x+1y2=x**2plt.figure(num=2,figsize=(8,5))plt.plot(x,y1,color='red',linewidth=2,linestyle='--')plt.plot(x,y2)#进行画图plt.xlim(-1,2)plt.ylim(-2,3)new_ticks=np.linspace(-1,2,5)#小标从-1到2分为5个单位plt.xticks(new_ticks)#进行替换新下标plt.yticks([-2,-1,1,2,], [r'$really\ bad$','$bad$','$well$','$really\ well$'])ax=plt.gca()#gca=get current axisax.spines['right'].set_color('none')#边框属性设置为none 不显示ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')#使用xaxis.set_ticks_position设置x坐标刻度数字或名称的位置 所有属性为top、bottom、both、default、noneax.spines['bottom'].set_position(('data', 0))#使用.spines设置边框x轴；使用.set_position设置边框位置，y=0位置 位置所有属性有outward、axes、dataax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0))#坐标中心点在(0,0)位置plt.show() 4.3添加图例matplotlib中legend图例帮助我们展示数据对应的图像名称。123456789101112131415x=np.linspace(-3,3,50)y1=2*x+1y2=x**2plt.figure(num=2,figsize=(8,5))plt.xlim(-1,2)plt.ylim(-2,3)new_ticks=np.linspace(-1,2,5)#小标从-1到2分为5个单位plt.xticks(new_ticks)#进行替换新下标plt.yticks([-2,-1,1,2,], [r'$really\ bad$','$bad$','$well$','$really\ well$'])l1,=plt.plot(x,y1,color='red',linewidth=2,linestyle='--',label='linear line')l2,=plt.plot(x,y2,label='square line')#进行画图plt.legend(loc='best')#显示在最好的位置plt.show()#显示图 调整位置和名称，单独修改label信息，我们可以在plt.legend输入更多参数123456789101112131415plt.legend(handles=[l1, l2], labels=['up', 'down'], loc='best')#loc有很多参数 其中best自分配最佳位置''' 'best' : 0, 'upper right' : 1, 'upper left' : 2, 'lower left' : 3, 'lower right' : 4, 'right' : 5, 'center left' : 6, 'center right' : 7, 'lower center' : 8, 'upper center' : 9, 'center' : 10, ''' 4.4标注123456789101112131415161718192021222324252627x=np.linspace(-3,3,50)y = 2*x + 1plt.figure(num=1, figsize=(8, 5))plt.plot(x, y,)#移动坐标轴ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data', 0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data', 0))#标注信息x0=1y0=2*x0+1plt.scatter(x0,y0,s=50,color='b')plt.plot([x0,x0],[y0,0],'k--',lw=2.5)#连接(x0,y0)(x0,0) k表示黑色 lw=2.5表示线粗细#xycoords='data'是基于数据的值来选位置，xytext=(+30,-30)和textcoords='offset points'对于标注位置描述和xy偏差值，arrowprops对图中箭头类型设置plt.annotate(r'$2x0+1=%s$' % y0, xy=(x0, y0), xycoords='data', xytext=(+30, -30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle='-&gt;', connectionstyle="arc3,rad=.2"))#添加注视text（-3.7,3）表示选取text位置 空格需要用\进行转译 fontdict设置文本字体 plt.text(-3.7, 3, r'$This\ is\ the\ some\ text. \mu\ \sigma_i\ \alpha_t$', fontdict=&#123;'size': 16, 'color': 'r'&#125;)plt.show() 4.5能见度调整123456789101112131415161718192021x=np.linspace(-3, 3, 50)y=0.1*xplt.figure()plt.plot(x, y, linewidth=10, zorder=1)plt.ylim(-2, 2)#移动坐标轴ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data', 0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data', 0))#label.set_fontsize(12)重新调整字体大小 bbox设置目的内容的透明度相关参数 facecolor调节box前景色 edgecolor设置边框 alpha设置透明度 zorder设置图层顺序for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor='red', edgecolor='None', alpha=0.7, zorder=2))plt.show() 5.画图种类5.1Scatter散点图1234567891011n=1024X=np.random.normal(0,1,n)#每一个点的X值Y=np.random.normal(0,1,n)#每一个点的Y值T=np.arctan2(Y,X)#arctan2返回给定的X和Y值的反正切值#scatter画散点图 size=75 颜色为T 透明度为50% 利用xticks函数来隐藏x坐标轴plt.scatter(X,Y,s=75,c=T,alpha=0.5)plt.xlim(-1.5,1.5)plt.xticks(())#忽略xticksplt.ylim(-1.5,1.5)plt.yticks(())#忽略yticksplt.show() 5.2条形图123456789101112131415161718#基本图形n=12X=np.arange(n)Y1=(1-X/float(n))*np.random.uniform(0.5,1,n)Y2=(1-X/float(n))*np.random.uniform(0.5,1,n)plt.bar(X,+Y1,facecolor='#9999ff',edgecolor='white')plt.bar(X,-Y2,facecolor='#ff9999',edgecolor='white')#标记值for x,y in zip(X,Y1):#zip表示可以传递两个值 plt.text(x+0.4,y+0.05,'%.2f'%y,ha='center',va='bottom')#ha表示横向对齐 bottom表示向下对齐for x,y in zip(X,Y2): plt.text(x+0.4,-y-0.05,'%.2f'%y,ha='center',va='top')plt.xlim(-0.5,n)plt.xticks(())#忽略xticksplt.ylim(-1.25,1.25)plt.yticks(())#忽略yticksplt.show() 5.3等高线图123456789101112131415n=256x=np.linspace(-3,3,n)y=np.linspace(-3,3,n)X,Y=np.meshgrid(x,y)#meshgrid从坐标向量返回坐标矩阵#f函数用来计算高度值 利用contour函数把颜色加进去 位置参数依次为x,y,f(x,y)，透明度为0.75，并将f(x,y)的值对应到camp之中def f(x,y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 - y ** 2)plt.contourf(X,Y,f(X,Y),8,alpha=0.75,cmap=plt.cm.hot)#8表示等高线分成多少份 alpha表示透明度 cmap表示color map#使用plt.contour函数进行等高线绘制 参数依次为x,y,f(x,y)，颜色选择黑色，线条宽度为0.5C=plt.contour(X,Y,f(X,Y),8,colors='black',linewidth=0.5)#使用plt.clabel添加高度数值 inline控制是否将label画在线里面，字体大小为10plt.clabel(C,inline=True,fontsize=10)plt.xticks(())#隐藏坐标轴plt.yticks(())plt.show() 5.4Image图片利用matplotlib打印出图像123456789a = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3)#origin='lower'代表的就是选择的原点位置plt.imshow(a,interpolation='nearest',cmap='bone',origin='lower')#cmap为color mapplt.colorbar(shrink=.92)#右边颜色说明 shrink参数是将图片长度变为原来的92%plt.xticks(())plt.yticks(())plt.show() 出图方式 此处采用内插法中的nearest-neighbor 5.53D图像1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D#需另外导入模块Axes 3Dfig=plt.figure()#定义图像窗口ax=Axes3D(fig)#在窗口上添加3D坐标轴#将X和Y值编织成栅格X=np.arange(-4,4,0.25)Y=np.arange(-4,4,0.25)X,Y=np.meshgrid(X,Y)R=np.sqrt(X**2+Y**2)Z=np.sin(R)#高度值#将colormap rainbow填充颜色，之后将三维图像投影到XY平面做等高线图，其中ratride和cstride表示row和column的宽度ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap=plt.get_cmap('rainbow'))#rstride表示图像中分割线的跨图#添加XY平面等高线 投影到z平面ax.contourf(X,Y,Z,zdir='z',offset=-2,cmap=plt.get_cmap('rainbow'))#把图像进行投影的图形 offset表示比0坐标轴低两个位置ax.set_zlim(-2,2)plt.show() 6.多图合并显示6.1Subplot多合一显示均匀图中图：MatPlotLib可以组合许多的小图在大图中显示，使用的方法叫做subplot。 12345678910111213plt.figure()plt.subplot(2,1,1)#表示整个图像分割成2行2列，当前位置为1plt.plot([0,1],[0,1])#横坐标变化为[0,1] 竖坐标变化为[0,2]plt.subplot(2,3,4)plt.plot([0,1],[0,2])plt.subplot(2,3,5)plt.plot([0,1],[0,3])plt.subplot(2,3,6)plt.plot([0,1],[0,4])plt.show() 不均匀图中图 12345678910111213plt.figure()plt.subplot(2,1,1)#将整个窗口分割成2行1列，当前位置表示第一个图plt.plot([0,1],[0,1])#横坐标变化为[0,1],竖坐标变化为[0,1]plt.subplot(2,3,4)#将整个窗口分割成2行3列，当前位置为4plt.plot([0,1],[0,2])plt.subplot(2,3,5)plt.plot([0,1],[0,3])plt.subplot(2,3,6)plt.plot([0,1],[0,4])plt.show() 6.2SubPlot分格显示方法一 123456789101112131415161718192021import matplotlib.gridspec as gridspec#引入新模块plt.figure()'''使用plt.subplot2grid创建第一个小图，(3,3)表示将整个图像分割成3行3列，(0,0)表示从第0行0列开始作图，colspan=3表示列的跨度为3。colspan和rowspan缺省时默认跨度为1'''ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3) # stands for axesax1.plot([1, 2], [1, 2])ax1.set_title('ax1_title')#设置图的标题#将图像分割成3行3列，从第1行0列开始做图，列的跨度为2ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)#将图像分割成3行3列，从第1行2列开始做图，行的跨度为2ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)#将图像分割成3行3列，从第2行0列开始做图，行与列的跨度默认为1ax4 = plt.subplot2grid((3, 3), (2, 0))ax4.scatter([1, 2], [2, 2])ax4.set_xlabel('ax4_x')ax4.set_ylabel('ax4_y')ax5 = plt.subplot2grid((3, 3), (2, 1)) 方法二 12345678plt.figure()gs = gridspec.GridSpec(3, 3)#将图像分割成3行3列ax6 = plt.subplot(gs[0, :])#gs[0:1]表示图占第0行和所有列ax7 = plt.subplot(gs[1, :2])#gs[1,:2]表示图占第1行和第二列前的所有列ax8 = plt.subplot(gs[1:, 2])ax9 = plt.subplot(gs[-1, 0])ax10 = plt.subplot(gs[-1, -2])#gs[-1.-2]表示这个图占倒数第1行和倒数第2行plt.show() 方法三 1234567'''建立一个2行2列的图像窗口，sharex=True表示共享x轴坐标，sharey=True表示共享y轴坐标，((ax11,ax12),(ax13,1x14))表示从到至右一次存放ax11,ax12,ax13,ax114'''f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True)ax11.scatter([1,2], [1,2])ax11.scatter 坐标范围x为[1,2]，y为[1,2]plt.tight_layout()#表示紧凑显示图像plt.show() 6.3图中图123456789101112131415161718192021222324252627fig=plt.figure()#创建数据x=[1,2,3,4,5,6,7]y=[1,3,4,2,5,8,6]#绘制大图：假设大图的大小为10，那么大图被包含在由(1,1)开始，宽8高8的坐标系之中。left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height]) # main axesax1.plot(x, y, 'r')#绘制大图，颜色为redax1.set_xlabel('x')#横坐标名称为xax1.set_ylabel('y')ax1.set_title('title')#图名称为title#绘制小图，注意坐标系位置和大小的改变ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25])ax2.plot(y, x, 'b')#颜色为buueax2.set_xlabel('x')ax2.set_ylabel('y')ax2.set_title('title inside 1')#绘制第二个小兔plt.axes([0.6, 0.2, 0.25, 0.25])plt.plot(y[::-1], x, 'g')#将y进行逆序plt.xlabel('x')plt.ylabel('y')plt.title('title inside 2')plt.show() 6.4次坐标轴12345678910111213x=np.arange(0,10,0.1)y1=0.5*x**2y2=-1*y1fig, ax1 = plt.subplots()ax2 = ax1.twinx()#镜像显示ax1.plot(x, y1, 'g-')ax2.plot(x, y2, 'b-')ax1.set_xlabel('X data')ax1.set_ylabel('Y1 data', color='g')#第一个y坐标轴ax2.set_ylabel('Y2 data', color='b')#第二个y坐标轴plt.show() 7.动画12345678910111213141516171819from matplotlib import animation#引入新模块fig,ax=plt.subplots()x=np.arange(0,2*np.pi,0.01)#数据为0~2PI范围内的正弦曲线line,=ax.plot(x,np.sin(x))# line表示列表#构造自定义动画函数animate，用来更新每一帧上x和y坐标值，参数表示第i帧def animate(i): line.set_ydata(np.sin(x+i/100)) return line,#构造开始帧函数initdef init(): line.set_ydata(np.sin(x)) return line,# frame表示动画长度，一次循环所包含的帧数；interval表示更新频率 # blit选择更新所有点，还是仅更新新变化产生的点。应该选True，但mac用户选择False。ani=animation.FuncAnimation(fig=fig,func=animate,frames=200,init_func=init,interval=20,blit=False)plt.show() MatPlotLib之中还有很多画图方法，由于篇幅有限不再赘述，更多内容参考MatPlotLib Tutorials。 更多内容请关注公众号’谓之小一’，若有疑问可在公众号后台提问，随时回答，内容转载请注明出处。]]></content>
      <categories>
        <category>Python库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之NumPy使用教程]]></title>
    <url>%2F2018%2F03%2F13%2FPython%E4%B9%8BNumPy%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.NumPy概述NumPy(Numerical Python)是用Python进行科学计算的基础软件包。包含以下特点： 强大的N维数组对象Array 成熟的函数库 用于集成C/C++和Fortran代码的工具 实用的线性代数、傅立叶变换和随机生成函数 2.NumPy安装1pip install numpy或pip3 install numpy 3.NumPy引入1import numpy as np#为了方便实用numpy 采用np简写 4.NumPy方法123456array=np.array([[1,2,3],[4,5,6]])#将列表转换为矩阵 并转换为int类型print(array)'''[[1 2 3] [4 5 6]] ''' 4.1NumPy属性123456print('array of dim:',array.ndim)#矩阵的维度#array of dim:2print('array of shape',array.shape)#矩阵的行数和列数#array of shape:(2,3)print('number of size:',array.size)#元素的个数#number of size:6 4.2NumPy创建Array array:创建数组 dtype:指定数据类型 zeros:创建数据全为0 ones:创建数据全为1 empty:创建数据接近0 arange:指定范围内创建数据 linspace创建线段 创建数组123a=np.array([1,2,3])print(a)#[1,2,3] 指定数据dtype123456a=np.array([1,2,3],dtype=np.int)#指定为int类型print(a.dtype)#int 64b=np.array([1,2,3],dtype=np.float)#指定为float类型print(b.dtype)#float 64 创建特定数据123456a=np.array([[1,2,3],[4,5,6]])#矩阵 2行3列print(a)'''[[1 2 3] [4 5 6]] ''' 创建全0数组123456a=np.zeros((2,3))#数据全0 2行3列print(a)'''[[0 0 0] [0 0 0]] ''' 创建全1数组 指定特定类型dtype123456a=np.zeros((2,3),dtype=np.int)#数据全1 2行3列 同时指定类型print(a)'''[[1 1 1] [1 1 1]] ''' 创建全空数组 每个值接近0123456a=np.empty(2,3)#数据全为empty 3行4列print(a)'''[[ 0.00000000e+000 0.00000000e+000 2.12704693e-314] [ 2.12706024e-314 2.12706024e-314 2.12706024e-314]] ''' 用array创建连续数组123a=np.arange(1,10,2)#1到10的数据 2步长print(a)#[1 3 5 7 9] 用reshape改变数据形状123456a=np.arange(6).reshape(2,3)print(a)'''[[0 1 2] [3 4 5]] ''' 用linspace创建线段形数据123456a=np.linspace(1,10,20)#开始端1 结束端5 分割成10个数据 生成线段print(a)'''[ 1. 1.44444444 1.88888889 2.33333333 2.77777778 3.22222222 3.66666667 4.11111111 4.55555556 5. ] ''' 4.3NumPy基础运算基础运算之加、减、三角函数等1234567891011121314151617181920212223242526272829a=np.array([10,20,30,40])b=np.arange(4) #array[0,1,2,3]c=a+b#加法运算print(c)#[10,21,32,43]c=a-b#减法运算print(c)#[10.19,28,37]c=10*np.sin(a)#三角函数运算#[-5.44021111, 9.12945251, -9.88031624, 7.4511316 ]print(b&lt;3)#逻辑判断#[ True True True False]d=np.random.random((2,3))#随机生成2行3列的矩阵print(d)'''[[ 0.21116981 0.0804489 0.51855475] [ 0.38359164 0.55852973 0.73218811]]'''print(np.sum(d))#元素求和#2.48448292958print(np.max(d))#元素求最大值#0.732188108709print(np.min(d))#元素求最小值#0.0804488978886 多维矩阵运算123456789a=np.array([[1,1],[0,1]])b=np.arange(4).reshape((2,2))c=np.dot(a,b)#或c=a.dot(b)矩阵运算print(c)'''[[2 4] [2 3]] ''' 对行或列执行查找运算12345678910a=np.array([[1,2],[3,4]])print(a)'''[[1,2] [3,4]] '''print(np.max(a,axis=0))#axis=0时是对列进行操作#[3,4]print(np.min(a,axis=1))#axis=1是对行进行操作#[1,3] 矩阵索引操作1234567891011121314151617181920212223A=np.arange(2,14).reshape(3,4)print(A)'''[[2,3,4,5] [6,7,8,9] [10,11,12,13]] '''print(np.argmax(A))#矩阵中最大元素的索引#11print(np.argmin(A))#矩阵中最小元素的索引#0print(np.mean(A))#或者np.average(A)求解矩阵均值#7.5print(np.cumsum(A))#矩阵累加函数#[2 5 9 14 20 27 35 44 54 65 77 90]print(np.diff(A))#矩阵累差函数'''[[1 1 1] [1 1 1] [1 1 1]] '''print(np.nonzero(A))#将非0元素的行与列坐标分割开来#(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3])) 矩阵排序、转置、替换操作12345678910111213141516171819202122232425262728A=np.arange(14,2,-1).reshape((3,4))print(A)'''[[14 13 12 11] [10 9 8 7] [ 6 5 4 3]] '''print(np.sort(A))#排序'''[[11 12 13 14] [ 7 8 9 10] [ 3 4 5 6]] '''print(np.transpose(A))'''[[14 10 6] [13 9 5] [12 8 4] [11 7 3]] '''print(np.clip(A,5,9))#替换 判断当前矩阵元素是否比最小值小或比最大值大 若是则替换'''[[9 9 9 9] [9 9 8 7] [6 5 5 5]] ''' 5.索引一维索引123456789A=np.arange(0,12)print(A)#[ 0 1 2 3 4 5 6 7 8 9 10 11]print(A[1])#一维索引#1A=np.arange(0,12).reshape((3,4))print(A[0])#[0,1,2,3] 二维索引12345678910111213141516171819202122232425262728293031323334353637A=np.arange(0,12).reshape((3,4))print(A)'''[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] '''print(A[1][1])#或者A[1,1]#5print(A[1,1:3])#切片处理#[5,6]for row in A: print(A)'''[0 1 2 3][4 5 6 7][ 8 9 10 11] '''for col in A: print(col)'''[0 4 8][1 5 9][ 2 6 10][ 3 7 11] '''for item in A.flat: print(item)'''01...1011''' 6.NumPy之Array合并123456789A=np.array([1,1,1])B=np.array([2,2,2])print(np.vstack((A,B)))#上下合并'''[[1 1 1] [2 2 2]] '''print(np.hstack((A,B)))#左右合并#[1 1 1 2 2 2] 增加维度12345678910111213141516A=np.array([1,1,1])print(A.shape)#(3,)print(A[np.newaxis,:])#[[1 1 1]]print(A[np.newaxis,:].shape)#newaxis增加维度#(1,3)print(A[:,np.newaxis])'''[[1] [1] [1]] '''print(A[:,np.newaxis].shape)#（3,1） 多矩阵合并1234567891011121314151617181920212223A = np.array([1,1,1])[:,np.newaxis]B = np.array([2,2,2])[:,np.newaxis]print(np.concatenate((A,B,B,A),axis=0))#0表示上下合并'''[[1] [1] [1] [2] [2] [2] [2] [2] [2] [1] [1] [1]] '''print(np.concatenate((A,B,B,A),axis=1))#1表示左右合并'''[[1 2 2 1] [1 2 2 1] [1 2 2 1]] ''' 7.NumPy分割1234567891011121314151617181920212223242526272829A=np.arange(12).reshape((3,4))print(A)'''[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] '''print(np.split(A,3,axis=0))#横向分割成3部分 或者np.vsplit(A,3)#[array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8, 9, 10, 11]])]print(np.split(A,2,axis=1))#竖向分割成2部分 或者np.hsplit(A,2)'''[array([[0, 1], [4, 5], [8, 9]]), array([[ 2, 3], [ 6, 7], [10, 11]])] ''' print(np.array_split(A,3,axis=1))#不等量分割成3部分'''[array([[0, 1], [4, 5], [8, 9]]), array([[ 2], [ 6], [10]]), array([[ 3], [ 7], [11]])]''' 8.NumPy中copy和deep copy‘=’赋值方式会带有关联性12345678910111213141516a=np.arange(4)print(a)#[1 2 3 4]b=ac=ad=bprint(b is a)#Trueprint(c is a)#Trueprint(d is a)#Trueb[0]=5#改变b的值，a,c,d同样会进行改变print(a)#[5 2 3 4] ‘copy()’赋值方式没有关联性1234567a=np.arange(4)#deep copyprint(a)#[0 1 2 3]b=a.copy()a[0]=5print(b)#值并不发生改变#[0 1 2 3] 更多内容请关注公众号’谓之小一’，若有疑问可在公众号后台提问，随时回答，内容转载请注明出处。如果感觉不错的话，可以资助1元钱当作鼓励，Thank you谢谢!]]></content>
      <categories>
        <category>Python库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之Pandas使用教程]]></title>
    <url>%2F2018%2F03%2F12%2FPython%E4%B9%8BPandas%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.Pandas概述 Pandas是Python的一个数据分析包，该工具为解决数据分析任务而创建。 Pandas纳入大量库和标准数据模型，提供高效的操作数据集所需的工具。 Pandas提供大量能使我们快速便捷地处理数据的函数和方法。 Pandas是字典形式，基于NumPy创建，让NumPy为中心的应用变得更加简单。 2.Pandas安装1pip3 install pandas 3.Pandas引入1import pandas as pd#为了方便实用pandas 采用pd简写 4.Pandas数据结构4.1Series12345678910111213import numpy as npimport pandas as pds=pd.Series([1,2,3,np.nan,5,6])print(s)#索引在左边 值在右边'''0 1.01 2.02 3.03 NaN4 5.05 6.0dtype: float64 ''' 4.2DataFrameDataFrame是表格型数据结构，包含一组有序的列，每列可以是不同的值类型。DataFrame有行索引和列索引，可以看成由Series组成的字典。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106dates=pd.date_range('20180310',periods=6)df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=['A','B','C','D'])#生成6行4列位置print(df)#输出6行4列的表格''' A B C D2018-03-10 -0.092889 -0.503172 0.692763 -1.2613132018-03-11 -0.895628 -2.300249 -1.098069 0.4689862018-03-12 0.084732 -1.275078 1.638007 -0.2911452018-03-13 -0.561528 0.431088 0.430414 1.0659392018-03-14 1.485434 -0.341404 0.267613 -1.4933662018-03-15 -1.671474 0.110933 1.688264 -0.910599 '''print(df['B'])'''2018-03-10 -0.9272912018-03-11 -0.4068422018-03-12 -0.0883162018-03-13 -1.6310552018-03-14 -0.9299262018-03-15 -0.010904Freq: D, Name: B, dtype: float64 '''#创建特定数据的DataFramedf_1=pd.DataFrame(&#123;'A' : 1., 'B' : pd.Timestamp('20180310'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D' : np.array([3] * 4,dtype='int32'), 'E' : pd.Categorical(["test","train","test","train"]), 'F' : 'foo' &#125;)print(df_1)''' A B C D E F0 1.0 2018-03-10 1.0 3 test foo1 1.0 2018-03-10 1.0 3 train foo2 1.0 2018-03-10 1.0 3 test foo3 1.0 2018-03-10 1.0 3 train foo'''print(df_1.dtypes)'''A float64B datetime64[ns]C float32D int32E categoryF objectdtype: object'''print(df_1.index)#行的序号#Int64Index([0, 1, 2, 3], dtype='int64')print(df_1.columns)#列的序号名字#Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')print(df_1.values)#把每个值进行打印出来'''[[1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'test' 'foo'] [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'train' 'foo'] [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'test' 'foo'] [1.0 Timestamp('2018-03-10 00:00:00') 1.0 3 'train' 'foo']] '''print(df_1.describe())#数字总结''' A C Dcount 4.0 4.0 4.0mean 1.0 1.0 3.0std 0.0 0.0 0.0min 1.0 1.0 3.025% 1.0 1.0 3.050% 1.0 1.0 3.075% 1.0 1.0 3.0max 1.0 1.0 3.0'''print(df_1.T)#翻转数据''' 0 1 2 \A 1 1 1 B 2018-03-10 00:00:00 2018-03-10 00:00:00 2018-03-10 00:00:00 C 1 1 1 D 3 3 3 E test train test F foo foo foo 3 A 1 B 2018-03-10 00:00:00 C 1 D 3 E train F foo '''print(df_1.sort_index(axis=1, ascending=False))#axis等于1按列进行排序 如ABCDEFG 然后ascending倒叙进行显示''' F E D C B A0 foo test 3 1.0 2018-03-10 1.01 foo train 3 1.0 2018-03-10 1.02 foo test 3 1.0 2018-03-10 1.03 foo train 3 1.0 2018-03-10 1.0'''print(df_1.sort_values(by='E'))#按值进行排序''' A B C D E F0 1.0 2018-03-10 1.0 3 test foo2 1.0 2018-03-10 1.0 3 test foo1 1.0 2018-03-10 1.0 3 train foo3 1.0 2018-03-10 1.0 3 train foo''' ###5.Pandas选择数据123456789101112131415161718192021dates=pd.date_range('20180310',periods=6)df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=['A','B','C','D'])#生成6行4列位置print(df)''' A B C D2018-03-10 -0.520509 -0.136602 -0.516984 1.3575052018-03-11 0.332656 -0.094633 0.382384 -0.9143392018-03-12 0.499960 1.576897 2.128730 2.1974652018-03-13 0.540385 0.427337 -0.591381 0.1265032018-03-14 0.191962 1.237843 1.903370 2.1553662018-03-15 -0.188331 -0.578581 -0.845854 -0.056373 '''print(df['A'])#或者df.A 选择某列'''2018-03-10 -0.5205092018-03-11 0.3326562018-03-12 0.4999602018-03-13 0.5403852018-03-14 0.1919622018-03-15 -0.188331''' 切片选择12345678910111213print(df[0:3], df['20180310':'20180314'])#两次进行选择 第一次切片选择 第二次按照筛选条件进行选择''' A B C D2018-03-10 -0.520509 -0.136602 -0.516984 1.3575052018-03-11 0.332656 -0.094633 0.382384 -0.9143392018-03-12 0.499960 1.576897 2.128730 2.197465 A B C D2018-03-10 -0.520509 -0.136602 -0.516984 1.3575052018-03-11 0.332656 -0.094633 0.382384 -0.9143392018-03-12 0.499960 1.576897 2.128730 2.1974652018-03-13 0.540385 0.427337 -0.591381 0.1265032018-03-14 0.191962 1.237843 1.903370 2.155366 ''' 根据标签loc-行标签进行选择数据123456print(df.loc['20180312', ['A','B']])#按照行标签进行选择 精确选择 '''A 0.499960B 1.576897Name: 2018-03-12 00:00:00, dtype: float64''' 根据序列iloc-行号进行选择数据1234567891011121314151617print(df.iloc[3, 1])#输出第三行第一列的数据#0.427336827399print(df.iloc[3:5,0:2])#进行切片选择 ''' A B2018-03-13 0.540385 0.4273372018-03-14 0.191962 1.237843 '''print(df.iloc[[1,2,4],[0,2]])#进行不连续筛选''' A C2018-03-11 0.332656 0.3823842018-03-12 0.499960 2.1287302018-03-14 0.191962 1.903370 ''' 根据混合的两种ix1234567print(df.ix[:3, ['A', 'C']])''' A C2018-03-10 -0.919275 -1.3560372018-03-11 0.010171 -0.3800102018-03-12 0.285251 -1.174265 ''' 根据判断筛选12345678print(df[df.A &gt; 0])#筛选出df.A大于0的元素 布尔条件筛选''' A B C D2018-03-11 0.332656 -0.094633 0.382384 -0.9143392018-03-12 0.499960 1.576897 2.128730 2.1974652018-03-13 0.540385 0.427337 -0.591381 0.1265032018-03-14 0.191962 1.237843 1.903370 2.155366 ''' 6.Pandas设置数据根据loc和iloc设置12345678910111213141516171819202122232425dates = pd.date_range('20180310', periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)), index=dates, columns=['A', 'B', 'C', 'D'])print(df)''' A B C D2018-03-10 0 1 2 32018-03-11 4 5 6 72018-03-12 8 9 1111 112018-03-13 12 13 14 152018-03-14 16 17 18 192018-03-15 20 21 22 23'''df.iloc[2,2] = 999#单点设置df.loc['2018-03-13', 'D'] = 999print(df)''' A B C D2018-03-10 0 1 2 32018-03-11 0 5 6 72018-03-12 0 9 999 112018-03-13 0 13 14 9992018-03-14 0 17 18 192018-03-15 0 21 22 23''' 根据条件设置1234567891011df[df.A&gt;0]=999#将df.A大于0的值改变print(df)''' A B C D2018-03-10 0 1 2 32018-03-11 999 5 6 72018-03-12 999 9 999 112018-03-13 999 13 14 9992018-03-14 999 17 18 192018-03-15 999 21 22 23 ''' 根据行或列设置1234567891011df['F']=np.nanprint(df)''' A B C D2018-03-10 0 1 2 NaN2018-03-11 999 5 6 NaN2018-03-12 999 9 999 NaN2018-03-13 999 13 14 NaN2018-03-14 999 17 18 NaN2018-03-15 999 21 22 NaN ''' 添加数据1234567891011df['E'] = pd.Series([1,2,3,4,5,6], index=pd.date_range('20180313', periods=6))#增加一列print(df)''' A B C D E2018-03-10 0 1 2 NaN NaN2018-03-11 999 5 6 NaN NaN2018-03-12 999 9 999 NaN NaN2018-03-13 999 13 14 NaN 1.02018-03-14 999 17 18 NaN 2.02018-03-15 999 21 22 NaN 3.0''' 7.Pandas处理丢失数据处理数据中NaN数据1234567891011121314dates = pd.date_range('20180310', periods=6)df = pd.DataFrame(np.arange(24).reshape((6,4)), index=dates, columns=['A', 'B', 'C', 'D'])df.iloc[0,1]=np.nandf.iloc[1,2]=np.nanprint(df)''' A B C D2018-03-10 0 NaN 2.0 32018-03-11 4 5.0 NaN 72018-03-12 8 9.0 10.0 112018-03-13 12 13.0 14.0 152018-03-14 16 17.0 18.0 192018-03-15 20 21.0 22.0 23''' 使用dropna（）函数去掉NaN的行或列12345678print(df.dropna(axis=0,how='any'#))#0对行进行操作 1对列进行操作 any:只要存在NaN即可drop掉 all:必须全部是NaN才可drop''' A B C D2018-03-12 8 9.0 10.0 112018-03-13 12 13.0 14.0 152018-03-14 16 17.0 18.0 192018-03-15 20 21.0 22.0 23 ''' 使用fillna（）函数替换NaN值12345678910print(df.fillna(value=0))#将NaN值替换为0''' A B C D2018-03-10 0 0.0 2.0 32018-03-11 4 5.0 0.0 72018-03-12 8 9.0 10.0 112018-03-13 12 13.0 14.0 152018-03-14 16 17.0 18.0 192018-03-15 20 21.0 22.0 23 ''' 使用isnull()函数判断数据是否丢失123456789101112print(pd.isnull(df))#矩阵用布尔来进行表示 是nan为ture 不是nan为false''' A B C D2018-03-10 False True False False2018-03-11 False False True False2018-03-12 False False False False2018-03-13 False False False False2018-03-14 False False False False2018-03-15 False False False False '''print(np.any(df.isnull()))#判断数据中是否会存在NaN值#True 8.Pandas导入导出pandas可以读取与存取像csv、excel、json、html、pickle等格式的资料，详细说明请看官方资料123data=pd.read_csv('test1.csv')#读取csv文件data.to_pickle('test2.pickle')#将资料存取成pickle文件 #其他文件导入导出方式相同 9.Pandas合并数据axis合并方向1234567891011121314151617df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])df3 = pd.DataFrame(np.ones((3,4))*2, columns=['a','b','c','d'])res = pd.concat([df1, df2, df3], axis=0, ignore_index=True)#0表示竖项合并 1表示横项合并 ingnore_index重置序列index index变为0 1 2 3 4 5 6 7 8print(res)''' a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.06 2.0 2.0 2.0 2.07 2.0 2.0 2.0 2.08 2.0 2.0 2.0 2.0 ''' join合并方式123456789101112131415161718192021222324252627282930313233343536373839404142df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d', 'e'], index=[2,3,4])print(df1)''' a b c d1 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 0.0 0.0 0.0 0.0 '''print(df2)''' b c d e2 1.0 1.0 1.0 1.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.0 '''res=pd.concat([df1,df2],axis=1,join='outer')#行往外进行合并print(res)''' a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.04 NaN NaN NaN NaN 1.0 1.0 1.0 1.0 '''res=pd.concat([df1,df2],axis=1,join='outer')#行相同的进行合并print(res)''' a b c d b c d e2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0'''res=pd.concat([df1,df2],axis=1,join_axes=[df1.index])#以df1的序列进行合并 df2中没有的序列NaN值填充print(res)''' a b c d b c d e1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.03 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0''' append添加数据1234567891011121314151617181920212223242526df1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])df2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])df3 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])s1 = pd.Series([1,2,3,4], index=['a','b','c','d'])res=df1.append(df2,ignore_index=True)#将df2合并到df1的下面 并重置indexprint(res)''' a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 1.0 1.0 1.04 1.0 1.0 1.0 1.05 1.0 1.0 1.0 1.0'''res=df1.append(s1,ignore_index=True)#将s1合并到df1下面 并重置indexprint(res)''' a b c d0 0.0 0.0 0.0 0.01 0.0 0.0 0.0 0.02 0.0 0.0 0.0 0.03 1.0 2.0 3.0 4.0''' 10.Pandas合并merge依据一组key合并12345678910111213141516171819202122232425262728293031left = pd.DataFrame(&#123;'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']&#125;)print(left)''' A B key0 A0 B0 K01 A1 B1 K12 A2 B2 K23 A3 B3 K3'''right = pd.DataFrame(&#123;'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']&#125;)print(right)''' C D key0 C0 D0 K01 C1 D1 K12 C2 D2 K23 C3 D3 K3'''res=pd.merge(left,right,on='key')print(res)''' A B key C D0 A0 B0 K0 C0 D01 A1 B1 K1 C1 D12 A2 B2 K2 C2 D23 A3 B3 K3 C3 D3''' 依据两组key合并1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465left = pd.DataFrame(&#123;'key1': ['K0', 'K0', 'K1', 'K2'], 'key2': ['K0', 'K1', 'K0', 'K1'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']&#125;)print(left)''' A B key1 key20 A0 B0 K0 K01 A1 B1 K0 K12 A2 B2 K1 K03 A3 B3 K2 K1 '''right = pd.DataFrame(&#123;'key1': ['K0', 'K1', 'K1', 'K2'], 'key2': ['K0', 'K0', 'K0', 'K0'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']&#125;)print(right)''' C D key1 key20 C0 D0 K0 K01 C1 D1 K1 K02 C2 D2 K1 K03 C3 D3 K2 K0 '''res=pd.merge(left,right,on=['key1','key2'],how='inner')#内联合并print(res)''' A B key1 key2 C D0 A0 B0 K0 K0 C0 D01 A2 B2 K1 K0 C1 D12 A2 B2 K1 K0 C2 D2'''res=pd.merge(left,right,on=['key1','key2'],how='outer')#外联合并print(res)''' A B key1 key2 C D0 A0 B0 K0 K0 C0 D01 A1 B1 K0 K1 NaN NaN2 A2 B2 K1 K0 C1 D13 A2 B2 K1 K0 C2 D24 A3 B3 K2 K1 NaN NaN5 NaN NaN K2 K0 C3 D3'''res=pd.merge(left,right,on=['key1','key2'],how='left')#左联合并''' A B key1 key2 C D0 A0 B0 K0 K0 C0 D01 A1 B1 K0 K1 NaN NaN2 A2 B2 K1 K0 C1 D13 A2 B2 K1 K0 C2 D24 A3 B3 K2 K1 NaN NaN'''res=pd.merge(left,right,on=['key1','key2'],how='right')#右联合并print(res)''' A B key1 key2 C D0 A0 B0 K0 K0 C0 D01 A2 B2 K1 K0 C1 D12 A2 B2 K1 K0 C2 D23 NaN NaN K2 K0 C3 D3''' Indicator合并1234567891011121314151617181920212223242526272829303132333435df1 = pd.DataFrame(&#123;'col1':[0,1], 'col_left':['a','b']&#125;)print(df1)''' col1 col_left0 0 a1 1 b '''df2 = pd.DataFrame(&#123;'col1':[1,2,2],'col_right':[2,2,2]&#125;)print(df2)''' col1 col_right0 1 21 2 22 2 2 '''res=pd.merge(df1,df2,on='col1',how='outer',indicator=True)#依据col1进行合并 并启用indicator=True输出每项合并方式print(res)''' col1 col_left col_right _merge0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only'''res = pd.merge(df1, df2, on='col1', how='outer', indicator='indicator_column')#自定义indicator column名称print(res)''' col1 col_left col_right indicator_column0 0 a NaN left_only1 1 b 2.0 both2 2 NaN 2.0 right_only3 2 NaN 2.0 right_only''' 依据index合并1234567891011121314151617181920212223242526272829303132333435363738left = pd.DataFrame(&#123;'A': ['A0', 'A1', 'A2'], 'B': ['B0', 'B1', 'B2']&#125;, index=['K0', 'K1', 'K2'])print(left)''' A BK0 A0 B0K1 A1 B1K2 A2 B2 '''right = pd.DataFrame(&#123;'C': ['C0', 'C2', 'C3'], 'D': ['D0', 'D2', 'D3']&#125;, index=['K0', 'K2', 'K3'])print(right)''' C DK0 C0 D0K2 C2 D2K3 C3 D3'''res=pd.merge(left,right,left_index=True,right_index=True,how='outer')#根据index索引进行合并 并选择外联合并print(res)''' A B C DK0 A0 B0 C0 D0K1 A1 B1 NaN NaNK2 A2 B2 C2 D2K3 NaN NaN C3 D3'''res=pd.merge(left,right,left_index=True,right_index=True,how='inner')print(res)''' A B C DK0 A0 B0 C0 D0K2 A2 B2 C2 D2''' 更多内容请关注公众号’谓之小一’，若有疑问可在公众号后台提问，随时回答，内容转载请注明出处。「谓之小一」希望提供给读者别处看不到的内容，关于互联网、机器学习、数据挖掘、编程、书籍、生活…]]></content>
      <categories>
        <category>Python库</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向知乎的个性化推荐模型研究]]></title>
    <url>%2F2018%2F03%2F12%2F%E9%9D%A2%E5%90%91%E7%9F%A5%E4%B9%8E%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[面向知乎的个性化推荐模型研究《面向知乎的个性化推荐模型研究》论文是大二暑假完成的，已投到《计算机应用与软件》中文核心期刊。论文主要对知乎提出一种基于混合算法的个性化推荐模型。论文基于用户模型、问题模型、推荐模型构建推荐系统，提出Person Rank、Problem Rank，并结合其他算法来优化推荐结果，利用数据训练推荐模型，最终得到面向知乎的个性化推荐模型。 更多内容请关注公众号’谓之小一’，若有疑问可在公众号后台提问，随时回答，内容转载请注明出处。「谓之小一」希望提供给读者别处看不到的内容，关于互联网、机器学习、数据挖掘、编程、书籍、生活…]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
</search>
